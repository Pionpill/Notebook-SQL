这部分内容仅针对 InnoDB 引擎。

\section{schema 设计与管理}

首先，schema(模式) 是啥，不同的数据库有不同的定义，MySQL 在物理上将 schema 与数据库等价。从概念上讲，模式是一组相互关联的数据库对象，如表，表列，列的数据类型，索引，外键等等。

\subsection{选择优化的数据类型}

不管存储哪种类型的数据，下面几个简单的原则都有助于你做出更好的选择。

\begin{itemize}
    \item \textbf{更小的通常更好}: 尽量使用能够正确存储和表示数据的最小数据类型。更小的数据类型通常更快，消耗更少的空间与时间。
    \item \textbf{简单为好}: 简单数据类型的操作通常需要更少的CPU周期。例如，整型数据比字符型数据的比较操作代价更低。
    \item \textbf{尽量避免存储 NULL}: 如果查询中包含可为NULL的列，对MySQL来说更难优化，因为可为NULL的列使得索引、索引统计和值比较都更复杂。
\end{itemize}

\subsubsection{数值类型}

有两种基本类型的数字：整数和实数。MySQL为了兼容性支持很多别名，例如 INTEGER 映射到 INT， NUMERIC 映射到 DECIMAL，需要注意，并不是什么新的类型。

在使用整数类型时，有可选的 UNSIGNED 属性，可以提高正数上限的一倍，且没有性能影响。

MySQL可以为整数类型指定宽度，例如，INT（11），这对大多数应用毫无意义：它不会限制值的合法范围，只是规定了MySQL的一些交互工具（例如，MySQL命令行客户端）用来显示字符的个数。对于存储和计算来说，INT（1）和INT（20）是相同的。

浮点类型通常比DECIMAL使用更少的空间来存储相同范围的值。MySQL会使用DOUBLE进行浮点类型的内部计算。

由于额外的空间需求和计算成本，应该尽量只在对小数进行精确计算时才使用DECIMAL。假设要存储财务数据并精确到万分之一分，则可以把所有金额乘以一百万，然后将结果存储在BIGINT里，这样可以同时避免浮点存储计算不精确和DECIMAL精确计算代价高的问题。

\subsubsection{字符串类型}

存储引擎在内存中存储CHAR或VARCHAR值的方式可能与在磁盘上存储该值的方式不同，并且服务器在从存储引擎检索该值时可能会将其转换为另一种存储格式。

\begin{itemize}
    \item \textbf{VARCHAR} 变长字符串
    \begin{itemize}
        \item 需要额外使用1或2字节记录字符串的长度，假设采用latin1字符集，一个VARCHAR（10）的列需要11字节的存储空间。VARCHAR（1000）的列则需要1002个字节，因为需要2字节存储长度信息。
        \item varchar长度是以实际保存的字符串长度为准的。由于行是可变长度的，在更新时可能会增长，这会导致额外的工作。如果行的增长使得原位置无法容纳更多内容，InnoDB可能需要分割页面来容纳行。
    \end{itemize}    
    
    \item \textbf{CHAR} 定长字符串
    
    \begin{itemize}
        \item MySQL总是为定义的字符串长度分配足够的空间。当存储CHAR值时，MySQL删除所有尾随空格。如果需要进行比较，值会用空格填充。
        \item CHAR适合存储非常短的字符串，或者适用于所有值的长度都几乎相同的情况。
        \item 对于经常修改的数据，CHAR也比VARCHAR更好，因为固定长度的行不容易出现碎片。对于非常短的列，CHAR也比VARCHAR更高效。
    \end{itemize}
\end{itemize}

CHAR 的尾部截断问题：
\begin{sql}
CREATE TABLE char_test (
    char_col CHAR(10) NOT NULL,
    varchar_col VARCHAR(10) NOT NULL
);

INSERT INTO char_test(char_col, varchar_col) VALUES
    ('string1','string1'),
    (' string2',' string2'), 
    ('string3 ','string3 ');

SELECT CONCAT("'",char_col,"'"),CONCAT("'",varchar_col,"'") FROM char_test;
\end{sql}

执行上述代码，观察返回结果:

\begin{sql}
+--------------------------+-----------------------------+
| CONCAT("'",char_col,"'") | CONCAT("'",varchar_col,"'") |
+--------------------------+-----------------------------+
| 'string1'                | 'string1'                   |
| ' string2'               | ' string2'                  |
| 'string3'                | 'string3 '                  |
+--------------------------+-----------------------------+
\end{sql}

发现 CHAR 类型字符串的尾部空格被截断了，而 VARCHAR 却没有。

与CHAR和VARCHAR类似的类型还有BINARY和VARBINARY，它们存储的是二进制字符串。二进制字符串与常规字符串非常相似，但它们存储的是字节而不是字符。填充也不同：MySQL填充BINANRY用的是零字节而不是空格，并且在检索时不会去除填充值。

当需要存储二进制数据，并且希望MySQL将值作为字节而不是字符进行比较时，这些类型非常有用。字节比较的优势不仅仅是大小写不敏感。MySQL比较BINARY字符串时，每次按一个字节，并且根据该字节的数值进行比较。因此，二进制比较比字符比较简单得多，因此速度更快。

使用VARCHAR（5）和VARCHAR（200）存储'hello'的空间开销是一样的。但较大的列会使用更多的内存，因为MySQL通常会在内部分配固定大小的内存块来保存值。这对于使用内存临时表的排序或操作来说尤其糟糕。

\paragraph*{BLOB 与 TEXT 类型}

BLOB和TEXT都是为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。

与其他数据类型不同，MySQL把每个BLOB和TEXT值当作一个具有自己标识的对象来处理。存储引擎通常会专门存储它们。当BLOB和TEXT值太大时，InnoDB会使用独立的“外部”存储区域，此时每个值在行内需要1～4字节的存储空间，然后在外部存储区域需要足够的空间来存储实际的值。

MySQL对BLOB和TEXT列的排序与其他类型不同：它只对这些列的最前max\_sort\_length字节而不是整个字符串做排序。MySQL不能将BLOB和TEXT数据类型的完整字符串放入索引，也不能使用索引进行排序。

\fbox{
    \parbox{0.87\textwidth}{
        \begin{advise}
            在过去，某些应用程序接受上传的图像并将其作为BLOB数据存储在MySQL数据库中，这种方法便于将应用程序的数据保存在一起；但是，随着数据大小的增长，修改schema等操作会由于BLOB数据的大小而变得越来越慢。

            如果可以避免的话，不要在数据库中存储像图像这样的数据。相反，应该将它们写入单独的对象数据存储，并使用该表来跟踪图像的位置或文件名。
        \end{advise}
    }
}

\paragraph*{使用枚举代替字符串类型}

ENUM列可以存储一组预定义的不同字符串值。MySQL在存储枚举时非常紧凑，会根据列表值的数量压缩到1或者2字节中。在内部会将每个值在列表中的位置保存为整数。

ENUM字段是根据内部整数值排序的，而不是根据字符串本身。

MySQL将每个枚举值存储为整数，并且必须进行查找以将其转换为字符串表示，因此ENUM列有一些开销。这些开销通常可以被ENUM列的小尺寸所抵消，但并不总是如此。特别是，将CHAR/VARCHAR列联接到ENUM列可能比联接到另一个CHAR/VARCHAR列更慢。

\subsubsection{日期和时间类型}

当插入一行记录时没有指定第一个TIMESTAMP列的值，MySQL会将该列的值设置为当前时间。当更新一行记录时没有指定第一个TIMESTAMP列的值，MySQL默认也会将该列的值更新为当前时间。可以为任何TIMESTAMP列配置插入和更新行为。最后，TIMESTAMP列在默认情况下为NOT NULL。

\subsubsection{位压缩数据类型}

MySQL有几种使用值中的单个位来紧凑地存储数据的类型。所有这些位压缩类型，不管底层存储和处理方式如何，从技术上来说都是字符串类型。

\paragraph*{BIT} 可以使用BIT列存储一个或多个true/false值。BIT（1）定义一个包含1位的字段，BIT（2）存储2位的字段，依此类推；BIT列的最大长度为64位。InnoDB将每一列存储为足够容纳这些位的最小整数类型，所以使用BIT列不会节省任何存储空间。

MySQL在处理时会将BIT视为字符串类型，而不是数字类型。当检索BIT（1）的值时，结果是一个包含二进制值0或1的字符串，而不是ASCII码的“0”或“1”。

但是，如果在数字上下文中检索该值，则会将BIT字符串转换为数字。

\subsection{设计陷阱}

\subsubsection*{太多的列}

MySQL的存储引擎API通过在服务器和存储引擎之间以行缓冲区格式复制行来工作；然后，服务器将缓冲区解码为列。将行缓冲区转换为具有解码列的行数据结构的操作代价是非常高的。InnoDB的行格式总是需要转换的。这种转换的成本取决于列数。

当调查一个具有非常宽的表（数百列）的客户的高CPU消耗问题时，我们发现这种转换代价可能会变得非常昂贵，尽管实际上只使用了几列。如果计划使用数百列，请注意服务器的性能特征会有所不同。

\subsubsection*{太多的联接}

MySQL限制每个联接有61个表，即使联接数远小于61，规划和优化查询的成本对MySQL来说也会成为问题。一个粗略的经验法则是，如果需要以高并发性快速执行查询，那么每个查询最好少于十几个的表。

\newpage