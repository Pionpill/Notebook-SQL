\section{高性能索引}

索引，在MySQL中也叫作键（key），是存储引擎用于快速找到记录的一种数据结构。索引优化应该是对查询性能优化最有效的手段了。索引能够轻易将查询性能提高几个数量级，“最优”的索引有时比一个“好的”索引性能要好两个数量级。

\subsection{索引基础}

在MySQL中，先在索引结构中找到对应值，这样就可以找到包含这个值的记录。

\begin{sql}
SELECT first_name FROM sakila.actor WHERE actor_id=5;
\end{sql}

如果在actor\_id列上建了索引，则MySQL将使用该索引找到actor\_id为5的记录。也就是说，MySQL先在索引上按值进行查找，然后返回所有包含该值的记录。

索引可以包含一列或多列的值。如果索引包含多列，那么列的顺序也十分重要，因为MySQL只能有效地使用索引的最左前缀列。创建一个包含两列的索引，和创建两个只包含一列的索引是大不相同的。

\subsubsection{索引的类型}

MySQL中，索引是在存储引擎层而不是服务器层实现的。所以，并没有统一的索引标准：不同存储引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。

\paragraph*{B-tree 索引}

如果没有特别指明类型，那么多半说的是B-tree索引，它使用B-tree数据结构来存储数据。InnoDB 使用的是 B+tree\footnote{InnoDB B+树参考文章: \url{https://blog.csdn.net/b_x_p/article/details/86434387}}。

B-tree索引能够加快数据访问的速度，这是因为有了索引，在查询某些条件的数据时，存储引擎不再需要进行全表扫描。而是从索引的根节点开始进行搜索，根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点，这些指针实际上定义了子节点页中值的上限和下限。最终存储引擎要么找到对应的值，要么该记录不存在。

叶子节点比较特殊，它们的指针指向的是被索引的数据，而不是其他的节点页。

B-tree是按照索引列中的数据大小顺序存储的，所以很适合按照范围来查询。例如，在一个基于文本列的索引树上遍历，按字母顺序传递连续的值进行范围查找是非常合适的。

索引对多个值进行排序的依据是CREATE TABLE语句中定义索引时列的顺序。

自适应哈希索引。InnoDB存储引擎有一个被称为自适应哈希索引的特性。当InnoDB发现某些索引值被非常频繁地被访问时，它会在原有的B-tree索引之上，在内存中再构建一个哈希索引。这个过程是完全自动化的，用户无法进行控制或者配置。不过，可以通过参数彻底关闭自适应哈希索引这个特性。

可以使用B-tree索引的查询类型。B-tree索引适用于全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找。

\paragraph*{全文索引}

FULLTEXT 是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。在相同的列上同时创建全文索引和基于值的B-tree索引并不会有冲突，全文索引适用于MATCH AGAINST操作，而不是普通的WHERE条件操作。

\paragraph*{使用索引的优点}

索引最主要的优点：可以让服务器快速地定位到表的指定位置。

最常见的B-tree索引，按照顺序存储数据，所以MySQL可以用来做ORDER BY和GROUP BY操作。因为数据是有序的，所以B-tree也就会将相关的列值都存储在一起。最后，因为索引中存储了实际的列值，所以某些查询只使用索引就能够完成全部查询。据此特性，总结下来索引有如下三个优点：

\begin{itemize}
    \item 索引大大减少了服务器需要扫描的数据量。
    \item 索引可以帮助服务器避免排序和临时表。
    \item 索引可以将随机I/O变为顺序I/O。
\end{itemize}

\subsection{高性能索引策略}

\subsubsection{前缀索引和索引的选择性}

有时候为了提升索引的性能，同时也节省索引空间，可以只对字段的前一部分字符进行索引，这样做的缺点是，会降低索引的选择性。

\begin{equation}
\text{选择性} = \frac{\text{不重复的索引值(基数)}}{\text{数据表的记录总数}} \nonumber
\end{equation}

索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。

一般情况下，列前缀的选择性也是足够高的，足以满足查询性能。对于BLOB、TEXT或者很长的VARCHAR类型的列，必须使用前缀索引，因为MySQL并不支持对这些列的完整内容进行索引。

具体选择多少个前缀创建索引要视情况而定，常用的办法是比较不使用前缀索引和使用前缀索引情况下的选择性，越接近越好，同时也需要考虑空间。

创建一个前缀索引的语句如下:
\begin{sql}
ALTER TABLE table ADD KEY (city(7));
\end{sql}

前缀索引是一种能使索引更小、更快的有效办法，但它也有缺点：MySQL无法使用前缀索引做ORDER BY和GROUP BY操作，也无法使用前缀索引做覆盖扫描。

\subsubsection{多列索引}

首先，多列索引不是为每一个列创建索引，其次多列索引的次序十分重要。

在多列上独立地创建多个单列索引，在大部分情况下并不能提高MySQL的查询性能。MySQL引入了一种叫“索引合并”（index merge）的策略，它在一定程度上可以使用表中的多个单列索引来定位指定的行。在这种情况下，查询能够同时使用两个单列索引进行扫描，并将结果进行合并。这种算法有三个变种：OR条件的联合（union），AND条件的相交（intersection），组合前两种情况的联合及相交。

索引合并策略有时候效果非常不错，但更多的时候，它说明了表中的索引建得很糟糕。如果在EXPLAIN中看到有索引合并，那么就应该好好检查一下查询语句的写法和表的结构，看是不是已经是最优的。

\subsubsection{选择合适的索引列顺序}

在一个多列B-tree索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等等。所以索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的ORDER BY、GROUP BY和DISTINCT等子句的查询需求。

当不需要考虑排序和分组时，将选择性最高的列放在前面通常是很好的。这时索引的作用只是优化查询语句中的WHERE条件。

然而，性能不只依赖于所有索引列的选择性（整体基数），也和查询条件的具体值有关，也就是和值的分布有关。这和前面介绍的选择前缀的长度需要考虑的因素一样。可能需要根据那些运行频率最高的查询来调整索引列的顺序，让这种情况下索引的选择性最高。

举个例子:
\begin{sql}
SELECT * FROM payment WHERE staff_id = 2 AND customer_id = 584;
\end{sql}

是应该创建一个（staff\_id、customer\_id）索引还是应该颠倒一下顺序？这时，可以通过运行某些查询来确定在这个表中值的分布情况，并确定哪列的选择性更高。

\subsubsection{聚簇索引}

聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。当表有聚簇索引时，它的数据行实际上存放在索引的叶子页（leaf page）中。InnoDB根据主键聚簇数据。主键的逻辑顺序就是数据存储的物理顺序。

如果你没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。这样做的缺点在于，所有需要使用这种隐藏主键的表都依赖一个单点的“自增值”，这可能会导致非常高的锁竞争，从而出现性能问题。

聚簇索引的每一个叶子节点都包含了主键值、事务ID、用于事务和MVCC的回滚指针，以及所有的剩余列。如果主键是一个列前缀索引，InnoDB也会包含完整的主键列和剩下的其他列。

InnoDB的二级索引的叶子节点中存储的是主键值，并以此作为指向行的“指针”。

最好避免随机的（不连续且值的分布范围非常大）聚簇索引，特别是对于I/O密集型的应用。例如，从性能的角度考虑，使用UUID作为聚簇索引会很糟糕：它使得聚簇索引的插入变得完全随机，这就是最糟糕的情况，数据本身没有任何聚集特性。

主键顺序插入会带来高聚集的好处，但在高并发的工作负载下，在InnoDB中按主键顺序插入可能会造成明显的写入竞争。主键的上界会成为“热点”。因为所有的插入都发生在这里，所以并发插入可能导致间隙锁竞争。另一个热点可能是AUTO\_INCREMENT锁机制。

\subsubsection{覆盖索引}

如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为覆盖索引。需要注意的是，只有B-tree索引可以用于覆盖索引。

覆盖索引是非常有用的工具，能够极大地提高性能。如果查询只需要扫描索引而无须回表，会带来很大的性能提升。

当执行一个被索引覆盖的查询（也叫作索引覆盖查询）时，在EXPLAIN的Extra列可以看到“Using index”的信息。

在大多数存储引擎中，索引只能覆盖那些只访问索引中部分列的查询，不过，可以更进一步优化InnoDB。回想一下，InnoDB的二级索引的叶子节点都包含了主键的值，这意味着InnoDB的二级索引可以有效地利用这些“额外”的主键列来覆盖查询。

\subsubsection{使用索引扫描来做排序}

MySQL有两种方式可以生成有序的结果：通过排序操作，或者按索引顺序扫描。如果在EXPLAIN的输出结果中，type列的值为“index”，则说明MySQL使用了索引扫描来做排序。

扫描索引本身是很快的，因为只需要从一条索引记录移动到紧接着的下一条记录。但如果索引不能覆盖查询所需的全部列，那么就不得不每扫描一条索引记录都回表查询一次对应的记录。这基本上都是随机I/O，因此按索引顺序读取数据的速度通常要比顺序地全表扫描慢，尤其是在I/O密集型的应用负载上。

MySQL可以使用同一个索引既满足排序，又用于查找行。因此，如果可能，设计索引时应该尽可能地同时满足这两项任务，这样是最好的。

只有当索引的顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，MySQL才能使用索引来对结果做排序。如果查询需要联接多张表，则只有当ORDER BY子句引用的字段全部在第一个表中时，才能使用索引做排序。ORDER BY子句和查找型查询的限制是一样的：需要满足索引的最左前缀的要求，否则，MySQL需要执行排序操作，而无法利用索引排序。

\subsubsection{冗余和重复索引}

MySQL允许在相同列上创建多个相同的索引。虽然MySQL会抛出一个警告，但是并不会阻止你这么做。MySQL需要单独维护重复的索引，优化器在优化查询的时候也需要逐个地进行评估，这会影响性能，同时也浪费磁盘空间。

重复索引是指在相同的列上按照相同顺序创建的相同类型的索引。有时，还是会在不经意间创建重复索引，例如下面的代码：

\begin{sql}
CREATE TABLE test(
    ID INT NOT NULL PRIMARY KEY,
    A INT NOT NULL,
    B INT NOT NULL,
    UNIQUE(ID),
    INDEX(ID)
);
\end{sql}

先加上唯一限制，然后再加上索引以供查询使用。事实上，MySQL的唯一限制和主键限制都是通过索引实现的，因此，上面的写法实际上在相同的列上创建了三个重复的索引。

冗余索引和重复索引有一些不同。如果创建了索引（A，B），再创建索引（A）就是冗余索引，因为这只是前一个索引的前缀索引，因此，索引（A，B）也可以当作索引（A）来使用（这种冗余只是对B-tree索引来说的）。但是如果再创建索引（B，A），则不是冗余索引，索引（B）也不是，因为B不是索引（A，B）的最左前缀列。

冗余索引通常发生在为表添加新索引的时候。例如，有人可能会增加一个新的索引（A，B）而不是扩展已有的索引（A）。还有一种情况是，将一个索引扩展为（A，ID），其中ID是主键，因为主键列已经包含在二级索引中了，所以这也是冗余的。

有时候出于性能方面的考虑也需要冗余索引，因为扩展已有的索引会导致其变得太大，从而影响其他使用该索引的查询的性能。

一般来说，增加索引会提高 SELECT 操作速度，但会导致 INSERT，UPDATE，DELETE 等操作的速度变慢。

\subsubsection{未使用的索引}

除了冗余索引和重复索引，可能还会有一些服务器永远不用的索引。这样的索引完全是累赘，建议删除。

找到未使用索引的最好办法就是使用系统数据库performance\_schema和sys。在sys数据库中，在table\_io\_waits\_summary\_by\_index\_usage视图中可以非常简单地知道哪些索引从来没有被使用过。

\subsection{维护索引和表}

维护表有三个主要目的：找到并修复损坏的表，维护准确的索引统计信息，减少碎片。

\subsubsection{找到并修复损坏的表}

如果表出现了莫须有的错误，可以尝试使用 CHECK TABLE 来检查是否发生了表损坏(有些存储引擎不支持)。如果确定表存在问题，可以使用 REPAIR TABLE 命令来修复损坏的表。如果引擎也不支持这个语句，建立换个引擎。

\begin{sql}
ALTER TABLE <table> ENGINE = InnoDB;
\end{sql}

如果上述的方法无法恢复数据表，可以从备份中回复，或者尝试从损坏的数据文件中恢复数据。

果是InnoDB存储引擎的表发生了损坏，那么一定是发生了严重的错误，需要立刻调查一下原因。InnoDB一般不会出现损坏，它的设计保证了它并不容易被损坏。如果发生了，一般要么是数据库的硬件问题，要么是由于数据库管理员的误操作，抑或是InnoDB本身的缺陷（不太可能）。不存在什么查询能够让InnoDB表损坏，也不用担心暗处有“陷阱”。如果某条查询导致InnoDB数据的损坏，那么一定是遇到了bug，而不是查询的问题。